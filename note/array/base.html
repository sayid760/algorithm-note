<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>数组 | 前端进阶-算法</title>
    <meta name="description" content="呵呵博客">
    <meta name="generator" content="VuePress 1.3.1">
    <link rel="shortcut icon" href="/favicon.ico">
    
    <link rel="preload" href="/assets/css/0.styles.d3da02ba.css" as="style"><link rel="preload" href="/assets/js/app.c9ff0550.js" as="script"><link rel="preload" href="/assets/js/2.1884c06c.js" as="script"><link rel="preload" href="/assets/js/3.b3f25fe0.js" as="script"><link rel="prefetch" href="/assets/js/10.e69a3114.js"><link rel="prefetch" href="/assets/js/11.3be090fb.js"><link rel="prefetch" href="/assets/js/12.20fdcf04.js"><link rel="prefetch" href="/assets/js/13.776c6a33.js"><link rel="prefetch" href="/assets/js/14.ce7f8dd3.js"><link rel="prefetch" href="/assets/js/15.22f65b5f.js"><link rel="prefetch" href="/assets/js/16.15e06b61.js"><link rel="prefetch" href="/assets/js/17.0831c010.js"><link rel="prefetch" href="/assets/js/18.8a536186.js"><link rel="prefetch" href="/assets/js/19.17aff003.js"><link rel="prefetch" href="/assets/js/20.45a41b4f.js"><link rel="prefetch" href="/assets/js/21.0235bc37.js"><link rel="prefetch" href="/assets/js/22.92dd7221.js"><link rel="prefetch" href="/assets/js/23.50231d9b.js"><link rel="prefetch" href="/assets/js/24.c45e63b0.js"><link rel="prefetch" href="/assets/js/25.52cdda70.js"><link rel="prefetch" href="/assets/js/26.fa35e335.js"><link rel="prefetch" href="/assets/js/27.5a467639.js"><link rel="prefetch" href="/assets/js/28.81e1dbda.js"><link rel="prefetch" href="/assets/js/29.6b099154.js"><link rel="prefetch" href="/assets/js/30.0923d196.js"><link rel="prefetch" href="/assets/js/4.46d1ef53.js"><link rel="prefetch" href="/assets/js/5.f3b0b362.js"><link rel="prefetch" href="/assets/js/6.df452285.js"><link rel="prefetch" href="/assets/js/7.5dd8b7b7.js"><link rel="prefetch" href="/assets/js/8.157c587d.js"><link rel="prefetch" href="/assets/js/9.a1881e94.js">
    <link rel="stylesheet" href="/assets/css/0.styles.d3da02ba.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><!----> <span class="site-name">前端进阶-算法</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="主页" class="dropdown-title"><span class="title">主页</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/language/chinese/" class="nav-link">
  Chinese
</a></li><li class="dropdown-item"><!----> <a href="/language/japanese/" class="nav-link">
  Japanese
</a></li></ul></div></div><div class="nav-item"><a href="/test/test.html" class="nav-link">
  测试
</a></div><div class="nav-item"><a href="https://www.baidu.com" target="_blank" rel="noopener noreferrer" class="nav-link external">
  百度
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="主页" class="dropdown-title"><span class="title">主页</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/language/chinese/" class="nav-link">
  Chinese
</a></li><li class="dropdown-item"><!----> <a href="/language/japanese/" class="nav-link">
  Japanese
</a></li></ul></div></div><div class="nav-item"><a href="/test/test.html" class="nav-link">
  测试
</a></div><div class="nav-item"><a href="https://www.baidu.com" target="_blank" rel="noopener noreferrer" class="nav-link external">
  百度
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></div> <!----></nav>  <ul class="sidebar-links"><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading open"><span>字符串</span> <span class="arrow down"></span></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/note/string/index_01.html" class="sidebar-link">字符串</a></li><li><a href="/note/string/index_02.html" class="sidebar-link">算法</a></li></ul></section></li><li><a href="/note/array/base.html" class="active sidebar-link">数组</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/note/array/base.html#移动零" class="sidebar-link">移动零</a></li><li class="sidebar-sub-header"><a href="/note/array/base.html#盛水最多的容器" class="sidebar-link">盛水最多的容器</a></li><li class="sidebar-sub-header"><a href="/note/array/base.html#两数之和" class="sidebar-link">两数之和</a></li><li class="sidebar-sub-header"><a href="/note/array/base.html#三数之和" class="sidebar-link">三数之和</a></li><li class="sidebar-sub-header"><a href="/note/array/base.html#卡牌分组（归类）" class="sidebar-link">卡牌分组（归类）</a></li><li class="sidebar-sub-header"><a href="/note/array/base.html#种花问题（筛选）" class="sidebar-link">种花问题（筛选）</a></li><li class="sidebar-sub-header"><a href="/note/array/base.html#格雷编码（二进制）" class="sidebar-link">格雷编码（二进制）</a></li><li class="sidebar-sub-header"><a href="/note/array/base.html#按奇偶排序数组-ii" class="sidebar-link">按奇偶排序数组 II</a></li><li class="sidebar-sub-header"><a href="/note/array/base.html#最大间距" class="sidebar-link">最大间距</a></li><li class="sidebar-sub-header"><a href="/note/array/base.html#数组中得第k个最大元素" class="sidebar-link">数组中得第K个最大元素</a></li><li class="sidebar-sub-header"><a href="/note/array/base.html#缺失的第一个正数" class="sidebar-link">缺失的第一个正数</a></li><li class="sidebar-sub-header"><a href="/note/array/base.html#删除排序数组中的重复项" class="sidebar-link">删除排序数组中的重复项</a></li><li class="sidebar-sub-header"><a href="/note/array/base.html#众数" class="sidebar-link">众数</a></li><li class="sidebar-sub-header"><a href="/note/array/base.html#组合总和（回溯）" class="sidebar-link">组合总和（回溯）</a></li><li class="sidebar-sub-header"><a href="/note/array/base.html#旋转数组的最小数字-（二分查找）" class="sidebar-link">旋转数组的最小数字 （二分查找）</a></li><li class="sidebar-sub-header"><a href="/note/array/base.html#调整数组使奇数全部都位于偶数前面" class="sidebar-link">调整数组使奇数全部都位于偶数前面</a></li><li class="sidebar-sub-header"><a href="/note/array/base.html#打印从1到最大的n位数" class="sidebar-link">打印从1到最大的n位数</a></li></ul></li><li><a href="/note/regexp/base.html" class="sidebar-link">正则表达式</a></li><li><a href="/note/matrix/base.html" class="sidebar-link">矩阵</a></li><li><a href="/note/heap/base.html" class="sidebar-link">堆</a></li><li><a href="/note/stack/base.html" class="sidebar-link">栈</a></li><li><a href="/note/queue/base.html" class="sidebar-link">队列</a></li><li><a href="/note/linkList/base.html" class="sidebar-link">链表</a></li><li><a href="/note/hash/base.html" class="sidebar-link">哈希表</a></li><li><a href="/note/binaryTree/base.html" class="sidebar-link">二叉树</a></li><li><a href="/note/trie/base.html" class="sidebar-link">字典树/并查集</a></li><li><a href="/note/interval/base.html" class="sidebar-link">区间</a></li><li><a href="/note/recurion/base.html" class="sidebar-link">递归</a></li><li><a href="/note/dfs/base.html" class="sidebar-link">深度/广度优先搜索</a></li><li><a href="/note/ga/base.html" class="sidebar-link">贪心算法</a></li><li><a href="/note/dp/base.html" class="sidebar-link">动态规划</a></li><li><a href="/note/partition/base.html" class="sidebar-link">分治算法</a></li><li><a href="/note/backtrack/base.html" class="sidebar-link">回溯算法</a></li><li><a href="/note/binarySearch/base.html" class="sidebar-link">二分查找</a></li><li><a href="/note/summing/base.html" class="sidebar-link">技巧总结</a></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="数组"><a href="#数组" class="header-anchor">#</a> 数组</h1> <ul><li>查找：通过下标找值   O(1)复杂度</li> <li>插入：插入后，后面的元素要往后移动  O(n)几重循环，如果插到最后一位是O(1)</li> <li>删除：删除后，后面的元素往前移动（复杂度同插入）</li></ul> <p>插入和删除非多，可以用链表来改善</p> <h2 id="移动零"><a href="#移动零" class="header-anchor">#</a> 移动零</h2> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">solution</span><span class="token punctuation">(</span><span class="token parameter">arr</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">let</span> j<span class="token operator">=</span><span class="token number">0</span>
    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">let</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>arr<span class="token punctuation">.</span>length<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">!==</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
            arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span>
            <span class="token keyword">if</span><span class="token punctuation">(</span>i<span class="token operator">!=</span>j<span class="token punctuation">)</span><span class="token punctuation">{</span>
                arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span>  <span class="token comment">// [1, 0, 0, 3, 12]  [1, 3, 0, 0, 12] ...</span>
            <span class="token punctuation">}</span>
            j<span class="token operator">++</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> arr
<span class="token punctuation">}</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>  <span class="token function">solution</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">12</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">// [1, 3, 12, 0, 0]</span>
</code></pre></div><h2 id="盛水最多的容器"><a href="#盛水最多的容器" class="header-anchor">#</a> <a href="https://leetcode-cn.com/problems/container-with-most-water/" target="_blank" rel="noopener noreferrer">盛水最多的容器<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></h2> <p>思路：
方法一：定义一个max变量，先让第一根柱子遍历，去跟后面的柱子组成面积，把组成最大的面积记录到max里，然后遍历完成后第二根去遍历后面的柱子，也是组成面积，求最大面积的，最后会得到一个最大面积</p> <p>方法二：左右边界向中间收敛，取第一根柱子和最后一根柱子，让他们往里面走，谁的高度小，就往里面走（左右夹逼方法）</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">maxArea</span><span class="token punctuation">(</span><span class="token parameter">arr</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">let</span> max <span class="token operator">=</span> <span class="token number">0</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> j<span class="token operator">=</span>arr<span class="token punctuation">.</span>length<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span> i<span class="token operator">&lt;</span>j<span class="token punctuation">;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">let</span> minHeight <span class="token operator">=</span> arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">&lt;</span>arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">?</span> arr<span class="token punctuation">[</span>i<span class="token operator">++</span><span class="token punctuation">]</span><span class="token operator">:</span>arr<span class="token punctuation">[</span>j<span class="token operator">--</span><span class="token punctuation">]</span>
        max <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span>max<span class="token punctuation">,</span> <span class="token punctuation">(</span>j<span class="token operator">-</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token operator">*</span>minHeight<span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> max
<span class="token punctuation">}</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token function">maxArea</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">8</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">8</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">7</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
</code></pre></div><h2 id="两数之和"><a href="#两数之和" class="header-anchor">#</a> <a href="https://leetcode-cn.com/problems/two-sum/" target="_blank" rel="noopener noreferrer">两数之和<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></h2> <p>a+b = target 且不重复</p> <blockquote><p>给定 nums = [2, 7, 11, 15], target = 9 <br>
因为 nums[0] + nums[1] = 2 + 7 = 9 <br>
所以返回 [0, 1]</p></blockquote> <p>方法一：暴力求解，两层循环遍历，枚举a+枚举b=target
方法二：用哈希表存储，后面查询时间复杂度为O(1)</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">twoSum</span><span class="token punctuation">(</span><span class="token parameter">nums<span class="token punctuation">,</span> target</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token comment">// 1. 定义哈希和空数组，遍历目标数组，把值、索引放到map作为key、val</span>
    <span class="token keyword">let</span> map <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Map</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token keyword">let</span> arr <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">let</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>nums<span class="token punctuation">.</span>length<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        map<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> i<span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
    <span class="token comment">/* 2. 循环数组，找出可以被target相减的，且相减完的数组不等于循环j变量的，
        说明map.get(nums[j])+map.get(target - nums[j]) = target
    */</span>
    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">let</span> j<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>j<span class="token operator">&lt;</span>nums<span class="token punctuation">.</span>length<span class="token punctuation">;</span>j<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>map<span class="token punctuation">.</span><span class="token function">has</span><span class="token punctuation">(</span>target<span class="token operator">-</span>nums<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span>map<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>target <span class="token operator">-</span> nums<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token operator">!=</span>j <span class="token punctuation">)</span>
        arr<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>j<span class="token punctuation">,</span> map<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>target <span class="token operator">-</span> nums<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
        <span class="token keyword">return</span> arr
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token function">twoSum</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">7</span><span class="token punctuation">,</span> <span class="token number">11</span><span class="token punctuation">,</span> <span class="token number">15</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token number">9</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
</code></pre></div><h2 id="三数之和"><a href="#三数之和" class="header-anchor">#</a> <a href="https://leetcode-cn.com/problems/3sum/" target="_blank" rel="noopener noreferrer">三数之和<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></h2> <p>使得a + b + c = 0 且不重复的三元组</p> <blockquote><p>给定数组 nums = [-1, 0, 1, 2, -1, -4]， <br>
满足要求的三元组集合为： <br>
[[-1, 0, 1], [-1, -1, 2] ]</p></blockquote> <p>方法一：暴力求解，三重循环 O(n^3) <br>
方法二：hash表来记录 a b, a+b=-c  <br>
方法三：左右下标往中间推进   <br>
先排序</p> <p><img src="/assets/img/array_img_03.63e249dc.png" alt="Image text"></p> <h2 id="卡牌分组（归类）"><a href="#卡牌分组（归类）" class="header-anchor">#</a> 卡牌分组（归类）</h2> <p>给定一副牌，每张牌上都写着一个整数。<br>
此时，你需要选定一个数字 X，使我们可以将整副牌按下述规则分成 1 组或更多组：</p> <p>每组都有 X 张牌。<br>
组内所有的牌上都写着相同的整数。<br>
仅当你可选的 X &gt;= 2 时返回 true。</p> <blockquote><p>输入：[1,2,3,4,4,3,2,1] <br>
输出：true <br>
解释：可行的分组是 [1,1]，[2,2]，[3,3]，[4,4]</p></blockquote> <p>最大公约数：a能被数b整除，a就叫做b的倍数，b就叫做a的约数；几个整数中公有的约数，叫做这几个数的公约数；
比如12、16的公约数有1、2、4，其中最大的一个是4，4就是最大公约数</p> <p>思路：
1）用map或object统计出每张牌的个数: {1: 2, 2: 2, 3: 2, 4: 2} <br>
2）求出相邻两个数的最大公约数: [2,2,2,2] 遍历求出它们的最大公约数</p> <div class="language- extra-class"><pre class="language-text"><code>var hasGroupsSizeX = function (arr) {
    // 存储每张卡牌的总数
    // 修改排序的方式修改为直接统计每个相同字符的数量，思路不变
    let group = []
    let tmp = {}
    // 也可以用map，但是比较耗性能
    arr.forEach(item =&gt; {
        tmp[item] = tmp[item] ? tmp[item] + 1 : 1 
    })
    console.log(tmp)
    for (let v of Object.values(tmp)) {
        group.push(v)  // group ==&gt; [2, 2, 2, 2]
    }
    // 此时group已经存放的是每张牌的总数了（数组只遍历一遍，避免了排序和正则的耗时）
    // 求两个数的最大公约数
    let gcd = (a, b) =&gt; {
        return b === 0 ? a : gcd(b, a % b)
    }
    while (group.length &gt; 1) {
        let a = group.shift()
        let b = group.shift()
        let v = gcd(a, b)
        if (v === 1) {
            return false
        } else {
            group.unshift(v)
        }
    }
    return group.length ? group[0] &gt; 1 : false
}
console.log(hasGroupsSizeX([1, 2, 3, 4, 4, 3, 2, 1]))
</code></pre></div><h2 id="种花问题（筛选）"><a href="#种花问题（筛选）" class="header-anchor">#</a> 种花问题（筛选）</h2> <p>假设你有一个很长的花坛，一部分地块种植了花，另一部分却没有。可是，花卉不能种植在相邻的地块上，它们会争夺水源，两者都会死去。</p> <p>给定一个花坛（表示为一个数组包含0和1，其中0表示没种植花，1表示种植了花），和一个数 n 。能否在不打破种植规则的情况下种入 n 朵花？能则返回True，不能则返回False。</p> <blockquote><p>输入: flowerbed = [1,0,0,0,1], n = 1 <br>
输出: True</p></blockquote> <div class="language- extra-class"><pre class="language-text"><code>const canPlaceFlowers = (arr, n) =&gt; {
    // 计数器，可以种多少朵花
    let max = 0
    // 右边界补充[0,0,0]，最后一块地能不能种只取决于前面的是不是1，所以默认最后一块地的右侧是0（无须考虑右侧边界有阻碍）
    arr.push(0)
    for (let i = 0, len = arr.length - 1; i &lt; len; i++) {
        // 0表示可以种花
        if (arr[i] === 0) {
            if (i === 0 &amp;&amp; arr[1] === 0) {
                // 种一颗花
                max++
                i++
            } else if (arr[i - 1] === 0 &amp;&amp; arr[i + 1] === 0) {
                max++
                i++
            }
        }
    }
    return max &gt;= n
}
console.log(canPlaceFlowers([1,0,0,0,1], 1))


// 简洁版
var canPlaceFlowers = function(flowerbed, n) {
  	return n &lt;= ('0' + flowerbed.join('') + '0').split(/1+/) // 以1为分割点
        .reduce((a, c) =&gt;
            a + Math.floor((c.length - 1) / 2)
        , 0)
};
</code></pre></div><h2 id="格雷编码（二进制）"><a href="#格雷编码（二进制）" class="header-anchor">#</a> 格雷编码（二进制）</h2> <p>格雷编码是一个二进制数字系统，在该系统中，两个连续的数值仅有一个位数的差异。<br>
给定一个代表编码总位数的非负整数 n，打印其格雷编码序列。即使有多个不同答案，你也只需要返回其中一种。<br>
格雷编码序列必须以 0 开头。
<img src="/assets/img/array_img_02.13da4f8c.png" alt="Image text"></p> <div class="language- extra-class"><pre class="language-text"><code>const grayCode = (n) =&gt; {
  // 递归函数，用来算输入为n的格雷编码序列
  let make = (n) =&gt; {
      if (n === 1) {
          return ['0', '1']
      } else {
          let prev = make(n - 1)
          let result = []
          let max = Math.pow(2, n) - 1
          for (let i = 0, len = prev.length; i &lt; len; i++) {
              result[i] = `0${prev[i]}`
              result[max - i] = `1${prev[i]}`
          }
          return result
      }
  }
  return make(n)
}

/* const grayCode = (n) =&gt; {
  let res = []
  //  i&lt;pow(2, n) i小于2的n次方
  //  左移n位就是2的n次方
  for (var i = 0; i &lt; (1 &lt;&lt; n); i++) {
      res.push(i ^ (i &gt;&gt; 1))
  }
  return res
}*/

console.log(grayCode(2))
</code></pre></div><h2 id="按奇偶排序数组-ii"><a href="#按奇偶排序数组-ii" class="header-anchor">#</a> 按奇偶排序数组 II</h2> <p>给定一个非负整数数组 A， A 中一半整数是奇数，一半整数是偶数。</p> <p>对数组进行排序，以便当 A[i] 为奇数时，i 也是奇数；当 A[i] 为偶数时， i 也是偶数。</p> <blockquote><p>输入：[4,2,5,7]
输出：[4,5,2,7]
解释：[4,7,2,5]，[2,5,4,7]，[2,7,4,5] 也会被接受。</p></blockquote> <p>思路：定义一个空数组，偶数位放2、4，奇数放5、7</p> <div class="language- extra-class"><pre class="language-text"><code>const sortArrayByParityII = (arr) =&gt; {
  // 进行升序排序
  arr.sort((a, b) =&gt; a - b)
  // 声明一个空数组用来存储奇偶排序后的数组
  let r = []
  // 记录奇数、偶数位下标
  let odd = 1
  let even = 0
  // 对数组进行遍历
  arr.forEach(item =&gt; {
    if (item % 2 === 1) {
      r[odd] = item
      // 向后移动两位
      odd += 2
    } else {
      r[even] = item
      // 向后移动两位
      even += 2
    }
  })
  return r
}

</code></pre></div><h2 id="最大间距"><a href="#最大间距" class="header-anchor">#</a> 最大间距</h2> <p>给定一个无序的数组，找出数组在排序之后，相邻元素之间最大的差值。<br>
如果数组元素个数小于 2，则返回 0。</p> <blockquote><p>输入: [3,6,9,1] <br>
输出: 3 <br>
解释: 排序后的数组是 [1,3,6,9], 其中相邻元素 (3,6) 和 (6,9) 之间都存在最大差值 3</p></blockquote> <p>思路：<br>
1）数组排序 <br>
2）每次排序完就判断当前值跟它右边值的差距 <br> 
3）获取新的数组中的最大值</p> <div class="language- extra-class"><pre class="language-text"><code>const maximumGap = (arr) =&gt; {
  if (arr.length &lt; 2) {
    return 0
  }
  let max = 0
  let len = arr.length - 1
  let space
  for (let i = len, tmp; i &gt; 0; i--) {
    // 排序
    for (let j = 0; j &lt; i; j++) {
      tmp = arr[j]
      if (tmp &gt; arr[j + 1]) {
        arr[j] = arr[j + 1]
        arr[j + 1] = tmp
      }
    }
    if (i &lt; len) {
      // 等于最大值减当前值，最大值在右侧
      space = arr[i + 1] - arr[i]
      if (space &gt; max) {
        max = space
      }
    }
  }
  // 处理边界 [1, 13, 16, 19]  只处理到space=16-13，没有处理 13-1
  return Math.max(max, arr[1] - arr[0])
}
console.log(maximumGap([3,6,9,1]))
</code></pre></div><h2 id="数组中得第k个最大元素"><a href="#数组中得第k个最大元素" class="header-anchor">#</a> 数组中得第K个最大元素</h2> <p>在未排序的数组中找到第 k 个最大的元素。请注意，你需要找的是数组排序后的第 k 个最大的元素，而不是第 k 个不同的元素。</p> <blockquote><p>输入: [3,2,1,5,6,4] 和 k = 2 <br>
输出: 5</p></blockquote> <p>思路：<br>
1）排序 <br>
2）遍历</p> <div class="language- extra-class"><pre class="language-text"><code>const findKthLargest = (arr, k) =&gt; {
  let len = arr.length - 1
  for (let i = len, tmp; i &gt; len - k; i--) {
    for (let j = 0; j &lt; i; j++) {
      if (arr[j] &gt; arr[j + 1]) {
        tmp = arr[j]
        arr[j] = arr[j + 1]
        arr[j + 1] = tmp
      }
    }
  }
  // arr[len+1-k]
  return arr[len - (k - 1)]
}

// const findKthLargest = (arr, k) =&gt; {
//   return arr.sort((a, b) =&gt; b - a)[k - 1]
// }
</code></pre></div><h2 id="缺失的第一个正数"><a href="#缺失的第一个正数" class="header-anchor">#</a> 缺失的第一个正数</h2> <p>给你一个未排序的整数数组，请你找出其中没有出现的最小的正整数</p> <blockquote><p>输入: [1,2,0]  // 123，3没有所以是3 <br>
输出: 3</p></blockquote> <blockquote><p>输入: [3,4,-1,1]  // 2没有，所以是2 <br>
输出: 2</p></blockquote> <blockquote><p>输入: [7,8,9,11,12]  // 正整数从1开始，所以是1 <br>
输出: 2</p></blockquote> <p>注：0、-1不是正整数</p> <p>思路：未排序、整数数组、最小的正整数
1）过滤非正整数的
2）排序，每排序一次就判断一次（sort()是全部排序，效率低，没必要把数组全部排序一遍）</p> <ul><li>最小元素的索引i&gt;0时，当前元素跟前面的元素相减大于1，表示不相邻，返回当前元素前面的一位元素</li> <li>最小元素的索引i==0时，最小的等于1</li></ul> <div class="language- extra-class"><pre class="language-text"><code>const firstMissingPositive = (arr) =&gt; {
  // 过滤掉非正整数
  arr = arr.filter(item =&gt; item &gt; 0)
  // 实现选择排序，先拿到最小值，如果第一个元素不是1直接返回1，如果是1，就要比相邻元素差值
  for (let i = 0, len = arr.length, min; i &lt; len; i++) {
    min = arr[i]
    for (let j = i + 1; j &lt; len; j++) {
      if (arr[j] &lt; min) {
        let c = min
        min = arr[j]
        arr[j] = c
      }
    }
    arr[i] = min
    if (i &gt; 0) {
      // 大于一，表示两个数字不相邻
      if (arr[i] - arr[i - 1] &gt; 1) {
        return arr[i - 1] + 1
      }
    } else {
      if (min !== 1) {
        // 正整数从1开始，所以没有1就为1
        return 1
      }
    }
  }
  // 如果都每返回值，返回 最后的数+1
  return arr.length ? arr.pop() + 1 : 1
}
</code></pre></div><h2 id="删除排序数组中的重复项"><a href="#删除排序数组中的重复项" class="header-anchor">#</a> 删除排序数组中的重复项</h2> <p>给定一个排序数组，你需要在 原地删除重复出现的元素，使得每个元素只出现一次，返回移除后数组的新长度。<br>
不要使用额外的数组空间，你必须在 原地修改输入数组 并在使用 O(1) 额外空间的条件下完成。</p> <blockquote><p>示例:
给定 nums = [0,0,1,1,1,2,2,3,3,4],<br>
函数应该返回新的长度 5, 并且原数组 nums 的前五个元素被修改为 0, 1, 2, 3, 4。</p></blockquote> <div class="language- extra-class"><pre class="language-text"><code>const removeDuplicates = array =&gt; {
    const length = array.length
    let slowPointer = 0
    for (let fastPointer = 0; fastPointer &lt; length; fastPointer ++) {
        if (array[slowPointer] !== array[fastPointer]) {
            slowPointer++
            array[slowPointer] = array[fastPointer]
        }
    }
    return slowPointer+1
}
console.log(removeDuplicates([0,0,1,1,1,2,2,3,3,4]))
</code></pre></div><h2 id="众数"><a href="#众数" class="header-anchor">#</a> 众数</h2> <p>给定一个大小为 n 的数组，找出其中所有出现超过 ⌊ n/2 ⌋ 次的元素。<br>
说明: 要求算法的时间复杂度为 O(n)，空间复杂度为 O(1)。</p> <p>摩尔投票法：设置变量num存放数组元素，cout计算数量，遍历遇到相同的就+1，遇到不一样的-1，打平了count=0的时候，num更换成其他元素 <br>
遍历这个元素，对这个元素进行计数，再判断是否大于数组的一半 O(n)</p> <div class="language- extra-class"><pre class="language-text"><code>const find = array =&gt; {
    let count = 1
    let result = array[0]
    for (let i = 0; i &lt; array.lenght; i++) {
        if (count === 0) result = array[i]
        if (array[i] === result) {
            count++
        }else {
            count--
        }
    }
    return result
}
console.log(find([2,2,1,1,1,1,2,2]))
</code></pre></div><h2 id="组合总和（回溯）"><a href="#组合总和（回溯）" class="header-anchor">#</a> 组合总和（回溯）</h2> <p>给定一组不含重复数字的非负数组和一个非负目标数字，在数组中找出所有数加起来等于给定的目标数字的组合。</p> <blockquote><p>示例 1：<br>
输入：candidates = [2,3,6,7], target = 7, <br>
所求解集为：<br>
[[7], [2,2,3]]</p></blockquote> <p>遍历所有的情况来找出问题的解，在这个遍历过程当中，以深度优先的方式搜索解空间，并且在搜索过程中用剪枝函数避免无效搜索</p> <p>一个临时数组tmpArray，进入递归前push一个结果</p> <div class="language- extra-class"><pre class="language-text"><code>const find = (array, target) =&gt; {
    // 最外层数组
    let result = []
    // 深度遍历
    const dfs = (index, sum, tmpArray) =&gt; { //  tmpArray  --&gt; [2, 2]
        if (sum === target) { // 正好等于7，就把参数转数组push到result里
            result.push(tmpArray.slice())
        }
        if (sum &gt; target) {  // 2 3 3 &gt; 7
            return
        }
        // 递归主体
        for (let i = index; i &lt; array.length; i++) {
            //加入数组，递归，看是否能被组合成7    [2, 2, 2]   ---- &gt; 下一轮 [2, 2, 3]
            tmpArray.push(array[i])  
            dfs(i, sum + array[i], tmpArray)
            // 递归完把最后的拿掉，用完就丢弃，下轮循环，再加进去递归，看是否组合成7
            tmpArray.pop()
            // console.log(tmpArray) // tmpArray只是一个临时数组    [2, 2]
        }
    }
    dfs(0, 0, [])
    return result
}
console.log(find([2, 3, 6, 7], 7))
</code></pre></div><h2 id="旋转数组的最小数字-（二分查找）"><a href="#旋转数组的最小数字-（二分查找）" class="header-anchor">#</a> <a href="https://leetcode-cn.com/problems/xuan-zhuan-shu-zu-de-zui-xiao-shu-zi-lcof/" target="_blank" rel="noopener noreferrer">旋转数组的最小数字<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a> （二分查找）</h2> <ul><li>方法1：暴力求解 时间复杂度 O(N)</li></ul> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">var</span> <span class="token function-variable function">minArray</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">arr</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span>arr<span class="token punctuation">.</span>length<span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">return</span>
    <span class="token keyword">let</span> minArr<span class="token operator">=</span>arr<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>
    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">let</span> i<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span> i<span class="token operator">&lt;</span>arr<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        minArr <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">min</span><span class="token punctuation">(</span>minArr<span class="token punctuation">,</span> arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> minArr
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre></div><ul><li>方法2：暴力求解 es6扩展运算符</li></ul> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">var</span> <span class="token function-variable function">minArray</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">arr</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> Math<span class="token punctuation">.</span><span class="token function">min</span><span class="token punctuation">(</span><span class="token operator">...</span>arr<span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre></div><ul><li>方法3：循环二分，不断去更新存在于两个子数组(两个非递减排序子数组)中的下标。时间复杂度是O(log(n))<br> <img src="/assets/img/array_img_04.e8807b82.png" alt="Image text">
设置i, j指针分别指向numbers 数组左右两端，m=(i + j)/2为每次二分的中点（ m&lt;=m&lt;j ），可分为以下三种情况： <br>
当 numbers[m] &gt; numbers[j]时：m一定在左排序数组中，即旋转点x一定在[m + 1, j]闭区间内，因此执行 i = m + 1 <br>
当 numbers[m] &lt; numbers[j] 时：m一定在右排序数组中，即旋转点x一定在[i, m]闭区间内，因此执行 j = m <br>
当 numbers[m] == numbers[j] 时： 无法判断m在哪个排序数组中，即无法判断旋转点x在[i, m]还是[m + 1, j]区间中。解决方案： 执行 j = j - 1缩小判断范围<br>
返回值：当i=j时跳出二分循环，并返回numbers[i]即可。</li></ul> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">var</span> <span class="token function-variable function">minArray</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token parameter">nums</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    <span class="token keyword">let</span> l <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token keyword">let</span> r <span class="token operator">=</span> nums<span class="token punctuation">.</span>length <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span>l <span class="token operator">&lt;</span> r<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">let</span> mid <span class="token operator">=</span> <span class="token punctuation">(</span>l <span class="token operator">+</span> r<span class="token punctuation">)</span> <span class="token operator">&gt;&gt;</span> <span class="token number">1</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>nums<span class="token punctuation">[</span>mid<span class="token punctuation">]</span> <span class="token operator">&gt;</span> nums<span class="token punctuation">[</span>r<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            l <span class="token operator">=</span> mid <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>nums<span class="token punctuation">[</span>mid<span class="token punctuation">]</span> <span class="token operator">==</span> nums<span class="token punctuation">[</span>r<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            r<span class="token operator">--</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
            r <span class="token operator">=</span> mid<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> nums<span class="token punctuation">[</span>l<span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token function">minArray</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
</code></pre></div><ul><li>方法4：sort</li></ul> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">var</span> <span class="token function-variable function">minArray</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token parameter">nums</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> nums<span class="token punctuation">.</span><span class="token function">sort</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">a<span class="token punctuation">,</span>b</span><span class="token punctuation">)</span><span class="token operator">=&gt;</span><span class="token punctuation">(</span>a<span class="token operator">-</span>b<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>
<span class="token punctuation">}</span>
</code></pre></div><h2 id="调整数组使奇数全部都位于偶数前面"><a href="#调整数组使奇数全部都位于偶数前面" class="header-anchor">#</a> 调整数组使奇数全部都位于偶数前面</h2> <p>题目： 输入一个整数数组，实现一个函数， 来调整该数组中数字的顺序使得数组中所有的奇数位于数组的前半部分， 所有偶数位于数组的后半部分。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">var</span> <span class="token function-variable function">sortArrayByParity</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">arr</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">let</span> left <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
  <span class="token keyword">let</span> right <span class="token operator">=</span> arr<span class="token punctuation">.</span>length <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>
  <span class="token keyword">while</span> <span class="token punctuation">(</span>left <span class="token operator">&lt;</span> right<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">let</span> temp <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
      <span class="token keyword">if</span> <span class="token punctuation">(</span>arr<span class="token punctuation">[</span>left<span class="token punctuation">]</span> <span class="token operator">%</span> <span class="token number">2</span> <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
          left<span class="token operator">++</span><span class="token punctuation">;</span>
      <span class="token punctuation">}</span>
      <span class="token keyword">if</span> <span class="token punctuation">(</span>arr<span class="token punctuation">[</span>right<span class="token punctuation">]</span> <span class="token operator">%</span> <span class="token number">2</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
          right<span class="token operator">--</span><span class="token punctuation">;</span>
      <span class="token punctuation">}</span>
      temp <span class="token operator">=</span> arr<span class="token punctuation">[</span>left<span class="token punctuation">]</span><span class="token punctuation">;</span>
      arr<span class="token punctuation">[</span>left<span class="token punctuation">]</span> <span class="token operator">=</span> arr<span class="token punctuation">[</span>right<span class="token punctuation">]</span><span class="token punctuation">;</span>
      arr<span class="token punctuation">[</span>right<span class="token punctuation">]</span> <span class="token operator">=</span> temp<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">return</span> arr
<span class="token punctuation">}</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token function">sortArrayByParity</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">,</span> <span class="token number">7</span><span class="token punctuation">,</span> <span class="token number">8</span><span class="token punctuation">,</span> <span class="token number">9</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
</code></pre></div><h2 id="打印从1到最大的n位数"><a href="#打印从1到最大的n位数" class="header-anchor">#</a> <a href="https://leetcode-cn.com/problems/da-yin-cong-1dao-zui-da-de-nwei-shu-lcof/" target="_blank" rel="noopener noreferrer">打印从1到最大的n位数<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></h2> <p>最大的n位十进制数，比如2的最大2位十进制=99 ，3=999，得出规律等于end=10^n-1</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">var</span> <span class="token function-variable function">printNumbers</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">n</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> Array<span class="token punctuation">.</span><span class="token function">from</span><span class="token punctuation">(</span><span class="token punctuation">{</span>length<span class="token operator">:</span> <span class="token number">10</span><span class="token operator">**</span>n<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token parameter">item<span class="token punctuation">,</span> index</span><span class="token punctuation">)</span><span class="token operator">=&gt;</span> index<span class="token operator">+</span><span class="token number">1</span> <span class="token punctuation">)</span>   <span class="token comment">// Math.pow(10, n)</span>
<span class="token punctuation">}</span>

<span class="token comment">/* 或者这种求数值的整次方
  let max = 1;
  let x = 10;
  while (n) {
      if (n &amp; 1) {
          max = max * x;
      }
      x = x * x;
      n = n &gt;&gt; 1;
  }
*/</span>
</code></pre></div></div> <footer class="page-edit"><!----> <!----></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/note/string/index_02.html" class="prev">
        算法
      </a></span> <span class="next"><a href="/note/regexp/base.html">
        正则表达式
      </a>
      →
    </span></p></div> </main></div><div class="global-ui"><!----></div></div>
    <script src="/assets/js/app.c9ff0550.js" defer></script><script src="/assets/js/2.1884c06c.js" defer></script><script src="/assets/js/3.b3f25fe0.js" defer></script>
  </body>
</html>

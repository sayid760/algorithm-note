<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>队列 | 前端进阶-算法</title>
    <meta name="description" content="呵呵博客">
    <meta name="generator" content="VuePress 1.3.1">
    <link rel="shortcut icon" href="/favicon.ico">
    
    <link rel="preload" href="/assets/css/0.styles.d3da02ba.css" as="style"><link rel="preload" href="/assets/js/app.c9ff0550.js" as="script"><link rel="preload" href="/assets/js/2.1884c06c.js" as="script"><link rel="preload" href="/assets/js/4.46d1ef53.js" as="script"><link rel="prefetch" href="/assets/js/10.e69a3114.js"><link rel="prefetch" href="/assets/js/11.3be090fb.js"><link rel="prefetch" href="/assets/js/12.20fdcf04.js"><link rel="prefetch" href="/assets/js/13.776c6a33.js"><link rel="prefetch" href="/assets/js/14.ce7f8dd3.js"><link rel="prefetch" href="/assets/js/15.22f65b5f.js"><link rel="prefetch" href="/assets/js/16.15e06b61.js"><link rel="prefetch" href="/assets/js/17.0831c010.js"><link rel="prefetch" href="/assets/js/18.8a536186.js"><link rel="prefetch" href="/assets/js/19.17aff003.js"><link rel="prefetch" href="/assets/js/20.45a41b4f.js"><link rel="prefetch" href="/assets/js/21.0235bc37.js"><link rel="prefetch" href="/assets/js/22.92dd7221.js"><link rel="prefetch" href="/assets/js/23.50231d9b.js"><link rel="prefetch" href="/assets/js/24.c45e63b0.js"><link rel="prefetch" href="/assets/js/25.52cdda70.js"><link rel="prefetch" href="/assets/js/26.fa35e335.js"><link rel="prefetch" href="/assets/js/27.5a467639.js"><link rel="prefetch" href="/assets/js/28.81e1dbda.js"><link rel="prefetch" href="/assets/js/29.6b099154.js"><link rel="prefetch" href="/assets/js/3.b3f25fe0.js"><link rel="prefetch" href="/assets/js/30.0923d196.js"><link rel="prefetch" href="/assets/js/5.f3b0b362.js"><link rel="prefetch" href="/assets/js/6.df452285.js"><link rel="prefetch" href="/assets/js/7.5dd8b7b7.js"><link rel="prefetch" href="/assets/js/8.157c587d.js"><link rel="prefetch" href="/assets/js/9.a1881e94.js">
    <link rel="stylesheet" href="/assets/css/0.styles.d3da02ba.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><!----> <span class="site-name">前端进阶-算法</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="主页" class="dropdown-title"><span class="title">主页</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/language/chinese/" class="nav-link">
  Chinese
</a></li><li class="dropdown-item"><!----> <a href="/language/japanese/" class="nav-link">
  Japanese
</a></li></ul></div></div><div class="nav-item"><a href="/test/test.html" class="nav-link">
  测试
</a></div><div class="nav-item"><a href="https://www.baidu.com" target="_blank" rel="noopener noreferrer" class="nav-link external">
  百度
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="主页" class="dropdown-title"><span class="title">主页</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/language/chinese/" class="nav-link">
  Chinese
</a></li><li class="dropdown-item"><!----> <a href="/language/japanese/" class="nav-link">
  Japanese
</a></li></ul></div></div><div class="nav-item"><a href="/test/test.html" class="nav-link">
  测试
</a></div><div class="nav-item"><a href="https://www.baidu.com" target="_blank" rel="noopener noreferrer" class="nav-link external">
  百度
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></div> <!----></nav>  <ul class="sidebar-links"><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading open"><span>字符串</span> <span class="arrow down"></span></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/note/string/index_01.html" class="sidebar-link">字符串</a></li><li><a href="/note/string/index_02.html" class="sidebar-link">算法</a></li></ul></section></li><li><a href="/note/array/base.html" class="sidebar-link">数组</a></li><li><a href="/note/regexp/base.html" class="sidebar-link">正则表达式</a></li><li><a href="/note/matrix/base.html" class="sidebar-link">矩阵</a></li><li><a href="/note/heap/base.html" class="sidebar-link">堆</a></li><li><a href="/note/stack/base.html" class="sidebar-link">栈</a></li><li><a href="/note/queue/base.html" class="active sidebar-link">队列</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/note/queue/base.html#优先队列" class="sidebar-link">优先队列</a></li><li class="sidebar-sub-header"><a href="/note/queue/base.html#用队列实现栈" class="sidebar-link">用队列实现栈</a></li><li class="sidebar-sub-header"><a href="/note/queue/base.html#数据流中的第k大元素" class="sidebar-link">数据流中的第K大元素</a></li><li class="sidebar-sub-header"><a href="/note/queue/base.html#滑动窗口最大值" class="sidebar-link">滑动窗口最大值</a></li><li class="sidebar-sub-header"><a href="/note/queue/base.html#设计循环队列" class="sidebar-link">设计循环队列</a></li><li class="sidebar-sub-header"><a href="/note/queue/base.html#任务调度器" class="sidebar-link">任务调度器</a></li></ul></li><li><a href="/note/linkList/base.html" class="sidebar-link">链表</a></li><li><a href="/note/hash/base.html" class="sidebar-link">哈希表</a></li><li><a href="/note/binaryTree/base.html" class="sidebar-link">二叉树</a></li><li><a href="/note/trie/base.html" class="sidebar-link">字典树/并查集</a></li><li><a href="/note/interval/base.html" class="sidebar-link">区间</a></li><li><a href="/note/recurion/base.html" class="sidebar-link">递归</a></li><li><a href="/note/dfs/base.html" class="sidebar-link">深度/广度优先搜索</a></li><li><a href="/note/ga/base.html" class="sidebar-link">贪心算法</a></li><li><a href="/note/dp/base.html" class="sidebar-link">动态规划</a></li><li><a href="/note/partition/base.html" class="sidebar-link">分治算法</a></li><li><a href="/note/backtrack/base.html" class="sidebar-link">回溯算法</a></li><li><a href="/note/binarySearch/base.html" class="sidebar-link">二分查找</a></li><li><a href="/note/summing/base.html" class="sidebar-link">技巧总结</a></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="队列"><a href="#队列" class="header-anchor">#</a> 队列</h1> <ul><li>先入先出  操作都是O(1)</li> <li>优先队列：正常进，优先出</li></ul> <h2 id="优先队列"><a href="#优先队列" class="header-anchor">#</a> 优先队列</h2> <p>正常进，按照优先出，优先级可以设置的属性，按照属性来出（最大的先出，也可以最小的先出，也可以出现次数先出）
实现机制：</p> <ul><li><p>用堆heap来实现（Binary，Binomial，Fibonacci）
小顶堆：越小的越排在上面，父节点比子节点小，最小的永远在根节点；加元素时放最下面，然后再上浮调整
大顶堆：越大的越排在上面，父结点大于左右节点，最大的永远在根节点</p></li> <li><p>用二叉搜索树Binary Search Tree来实现</p></li></ul> <h2 id="用队列实现栈"><a href="#用队列实现栈" class="header-anchor">#</a> 用队列实现栈</h2> <h2 id="数据流中的第k大元素"><a href="#数据流中的第k大元素" class="header-anchor">#</a> 数据流中的第K大元素</h2> <blockquote><p>int k = 3; <br>
int[] arr = [4,5,8,2];  <br>
KthLargest kthLargest = new KthLargest(3, arr);  <br>
kthLargest.add(3);   // returns 4 <br>
kthLargest.add(5);   // returns 5</p></blockquote> <p>思路：
方法1：保存前K个最大的值；全部排序
方法2：优先队列，每次把最大的放在最上面，或把最小的放在最上面
小顶堆：把最小的放根结点，所以要保证元素个数等于K（意思是这个堆的个数为K个，最顶的是最小的，遍历数组的元素，如果有比它小的就不用进来排队了，如果比它大，就把最小的踢掉，剩下的元素重新调整log2^k）</p> <div class="language-js extra-class"><pre class="language-js"><code>
</code></pre></div><h2 id="滑动窗口最大值"><a href="#滑动窗口最大值" class="header-anchor">#</a> <a href="https://leetcode-cn.com/problems/sliding-window-maximum/" target="_blank" rel="noopener noreferrer">滑动窗口最大值<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></h2> <blockquote><p>输入: nums = [1,3,-1,-3,5,3,6,7], 和 k = 3 <br>
输出: [3,3,5,5,6,7] <br>
解释: <br>
滑动窗口的位置                最大值<br>
---------------               -----<br>
[1  3  -1] -3  5  3  6  7   ------&gt;    3<br>
1 [3  -1  -3] 5  3  6  7    ------&gt;    3<br>
1  3 [-1  -3  5] 3  6  7    ------&gt;    5<br>
1  3  -1 [-3  5  3] 6  7    ------&gt;    5<br>
1  3  -1  -3 [5  3  6] 7    ------&gt;    6<br>
1  3  -1  -3  5 [3  6  7]    ------&gt;   7</p></blockquote> <p>所有的滑动窗口题用队列去处理</p> <p>方法1：暴力求解，枚举窗口的起点位置，起点开始到len-k的最大值，写两个嵌套循环O(n*K)
方法2：线性队列，O(n+k)即O(n)一次解决
窗口移到2 3 4位置，5进来的时候，要跟窗口其他数对比，只要比5小，都可以从这个栈去掉</p> <p><img src="/assets/img/queue_img_03.15fba3ac.png" alt="Image text"></p> <h2 id="设计循环队列"><a href="#设计循环队列" class="header-anchor">#</a> 设计循环队列</h2> <p>循环队列是一种线性数据结构，其操作表现基于 FIFO（先进先出）原则并且队尾被连接在队首之后以形成一个循环。它也被称为“环形缓冲器”
循环队列的一个好处是我们可以利用这个队列之前用过的空间。在一个普通队列里，一旦一个队列满了，我们就不能插入下一个元素，即使在队列前面仍有空间。但是使用循环队列，我们能使用这些空间去存储新的值。<br>
循环队列可以高效利用存储空间，普通队列需要很大的存储空间，存储空间会往上跑，循环队列可以避免这个问题。</p> <p>你的实现应该支持如下操作：<br>
MyCircularQueue(k): 构造器，设置队列长度为 k 。<br>
Front: 从队首获取元素。如果队列为空，返回 -1 。<br>
Rear: 获取队尾元素。如果队列为空，返回 -1 。<br>
enQueue(value): 向循环队列插入一个元素。如果成功插入则返回真。<br>
deQueue(): 从循环队列中删除一个元素。如果成功删除则返回真。<br>
isEmpty(): 检查循环队列是否为空。<br>
isFull(): 检查循环队列是否已满。</p> <p><img src="/assets/img/queue_img_01.426ed57b.png" alt="Image text"></p> <div class="language- extra-class"><pre class="language-text"><code>class MyCircularQueue{
    constructor(k) {
        // 用来保存数据长度为k的数据结构
        this.list = Array(k)
        // 队首指针
        this.front = 0
        // 队尾的指针
        this.rear = 0
        // 队列的长度
        this.max = k
    }
    // 入队：rear指针指向哪里，哪里就可以入队，且rear指针+1
    enQueue(num) {
        if (this.isFull()) {
            return false
        } else {
            this.list[this.rear] = num
            // 指针向后移动
            this.rear = (this.rear + 1) % this.max
            return true
        }
    }
    // 出队：front指针指向谁，谁就出队，且front指针+1
    deQueue() {
        let v = this.list[this.front]
        this.list[this.front] = ''
        console.log('front-----&gt;'+this.front)
        // front指针往后移动
        this.front = (this.front + 1) % this.max
        console.log('front222-----&gt;'+this.front)
        return v
    }
    isEmpty() {
        return this.front === this.rear &amp;&amp; !this.list[this.front]
    }
    isFull() {
        return this.front === this.rear &amp;&amp; !!this.list[this.front]
    }
    Front() {
        return this.list[this.front]
    }
    rear() {
        let rear = this.rear - 1
        return this.list[rear &lt; 0 ? this.max - 1 : rear]
    }
}
const cQueue = new MyCircularQueue(5); // 设置长度为 3
cQueue.enQueue(1);  // 返回 true
cQueue.enQueue(2);  // 返回 true
cQueue.enQueue(3);  // 返回 true
cQueue.enQueue(4);  // 返回 false，队列已满
// cQueue.rear();  // 返回 3
// cQueue.isFull();  // 返回 true
cQueue.deQueue();  // 返回 true
cQueue.deQueue();  // 返回 true
cQueue.deQueue();  // 返回 true
// cQueue.enQueue(4);  // 返回 true
// cQueue.rear();  // 返回 4
console.log(cQueue)
</code></pre></div><h2 id="任务调度器"><a href="#任务调度器" class="header-anchor">#</a> 任务调度器</h2> <p>给定一个用字符数组表示的 CPU 需要执行的任务列表。其中包含使用大写的 A - Z 字母表示的26 种不同种类的任务。任务可以以任意顺序执行，并且每个任务都可以在 1 个单位时间内执行完。CPU 在任何一个单位时间内都可以执行一个任务，或者在待命状态。</p> <p>然而，两个相同种类的任务之间必须有长度为 n 的冷却时间，因此至少有连续 n 个单位时间内 CPU 在执行不同的任务，或者在待命状态。</p> <p>你需要计算完成所有任务所需要的最短时间。
示例 ：</p> <blockquote><p>输入：tasks = [&quot;A&quot;,&quot;A&quot;,&quot;A&quot;,&quot;B&quot;,&quot;B&quot;,&quot;B&quot;], n = 2 <br>
输出：8 <br>
解释：A -&gt; B -&gt; (待命) -&gt; A -&gt; B -&gt; (待命) -&gt; A -&gt; B. <br>
在本示例中，两个相同类型任务之间必须间隔长度为 n = 2 的冷却时间，而执行一个任务只需要一个单位时间，所以中间出现了（待命）状态。</p></blockquote> <p>思路：任务清单keys ['A','B'] 是用来遍历循环，拿到当前数量最多的任务，然后个push到临时队列tmp中，临时队列只能放到n+1个（3个）任务，不够放的就用'-'来补齐（做到两个相同类型任务之间必须长度为n）。执行完一个临时队列tmp后，再循环判断还有没有任务清单keys，有的话继续前面的动作，直到keys[0]=undefined为止</p> <p>步骤：<br>
1）先记录每类任务的数量 Q:{A:3, B:3} <br>
2）max记录最多数量的先执行，先被push到临时任务队列tmp中，这个tmp就是AB-AB-AB（不够n+1个的往里面补&quot;-&quot;）</p> <ul><li>获取任务清单keys（['A','B']），遍历任务清单找到数量最多的key，拿到数量最多的A先push到临时队列tmp中，表示执行这个队列，所以得把Q中A的数量减一，从任务清单keys清除A</li> <li>这个临时队列容量为n+1，所以能被循环小于n次，执行完一个临时队列后，把临时队列累加给p, 再去循环执行下一个临时队列
<img src="/assets/img/queue_img_02.f9785034.png" alt="Image text"></li></ul> <div class="language- extra-class"><pre class="language-text"><code>const leastInterval = (tasks, n) =&gt; {
    // 表示最终队列执行的结果
    let q = ''
    // 对归类进行存储
    let Q = {}
    tasks.forEach(item =&gt; {
        if (Q[item]) {
            Q[item]++
        } else {
            Q[item] = 1
        }
    });
    // 队列中还有任务就要循环，为什么为1，是因为效率问题，不要一直判断对象Q是否为空，会重复计算
    while (1) {
        // 处理边界问题
        // 任务清单：只要有key值，表示任务队列中还有，key值没有就表示已经都处理掉了，就不用每次去判断Q是否为空
        let keys = Object.keys(Q)
        if (!keys[0]) {
            break
        }
        // 处理任务：找到哪个数量最多，数量最多的就优先处理
        // 声明一个队列用来存储1+n任务单元
        let tmp = []
        for (let i = 0; i &lt;= n; i++) {
            // 记录最大值
            let max=0
            // 最大值名称
            let key
            // 最大值索引位置
            let pos
            // 任务清单中找当前任务还剩下多少
            keys.forEach((item, idx)=&gt;{
                // 找最大值
                if(Q[item]&gt;max){
                    max = Q[item]
                    key = item
                    pos = idx
                    // console.log(item)
                    // console.log(idx)
                }
            })
            // 判断是否找到最大值key，如果是就push到临时队列
            if(key){
                // console.log('11---&gt;'+key)
                tmp.push(key)
                // 在任务清单中清除
                keys.splice(pos, 1) //  [&quot;A&quot;, &quot;B&quot;] ===&gt; [&quot;B&quot;]
                Q[key]--
                if(Q[key]&lt;1){
                    delete Q[key]
                }
                // console.log('222---&gt;'+keys)
            }else{
                break
            }
        }
        // 如果不够，后面补什么
        q +=tmp.join('').padEnd(n+1,'-')
    }
    // 边界处理，最后不要出现冷却时间
    q = q.replace(/-+$/g, '')
    return q.length
}
const tasks = [&quot;A&quot;, &quot;A&quot;, &quot;A&quot;, &quot;B&quot;, &quot;B&quot;, &quot;B&quot;], n = 2
console.log(leastInterval(tasks, n)) 
</code></pre></div></div> <footer class="page-edit"><!----> <!----></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/note/stack/base.html" class="prev">
        栈
      </a></span> <span class="next"><a href="/note/linkList/base.html">
        链表
      </a>
      →
    </span></p></div> </main></div><div class="global-ui"><!----></div></div>
    <script src="/assets/js/app.c9ff0550.js" defer></script><script src="/assets/js/2.1884c06c.js" defer></script><script src="/assets/js/4.46d1ef53.js" defer></script>
  </body>
</html>

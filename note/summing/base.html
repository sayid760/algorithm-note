<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>前端进阶-算法</title>
    <meta name="description" content="呵呵博客">
    <meta name="generator" content="VuePress 1.3.1">
    <link rel="shortcut icon" href="/favicon.ico">
    
    <link rel="preload" href="/assets/css/0.styles.d3da02ba.css" as="style"><link rel="preload" href="/assets/js/app.c9ff0550.js" as="script"><link rel="preload" href="/assets/js/2.1884c06c.js" as="script"><link rel="preload" href="/assets/js/27.5a467639.js" as="script"><link rel="prefetch" href="/assets/js/10.e69a3114.js"><link rel="prefetch" href="/assets/js/11.3be090fb.js"><link rel="prefetch" href="/assets/js/12.20fdcf04.js"><link rel="prefetch" href="/assets/js/13.776c6a33.js"><link rel="prefetch" href="/assets/js/14.ce7f8dd3.js"><link rel="prefetch" href="/assets/js/15.22f65b5f.js"><link rel="prefetch" href="/assets/js/16.15e06b61.js"><link rel="prefetch" href="/assets/js/17.0831c010.js"><link rel="prefetch" href="/assets/js/18.8a536186.js"><link rel="prefetch" href="/assets/js/19.17aff003.js"><link rel="prefetch" href="/assets/js/20.45a41b4f.js"><link rel="prefetch" href="/assets/js/21.0235bc37.js"><link rel="prefetch" href="/assets/js/22.92dd7221.js"><link rel="prefetch" href="/assets/js/23.50231d9b.js"><link rel="prefetch" href="/assets/js/24.c45e63b0.js"><link rel="prefetch" href="/assets/js/25.52cdda70.js"><link rel="prefetch" href="/assets/js/26.fa35e335.js"><link rel="prefetch" href="/assets/js/28.81e1dbda.js"><link rel="prefetch" href="/assets/js/29.6b099154.js"><link rel="prefetch" href="/assets/js/3.b3f25fe0.js"><link rel="prefetch" href="/assets/js/30.0923d196.js"><link rel="prefetch" href="/assets/js/4.46d1ef53.js"><link rel="prefetch" href="/assets/js/5.f3b0b362.js"><link rel="prefetch" href="/assets/js/6.df452285.js"><link rel="prefetch" href="/assets/js/7.5dd8b7b7.js"><link rel="prefetch" href="/assets/js/8.157c587d.js"><link rel="prefetch" href="/assets/js/9.a1881e94.js">
    <link rel="stylesheet" href="/assets/css/0.styles.d3da02ba.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><!----> <span class="site-name">前端进阶-算法</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="主页" class="dropdown-title"><span class="title">主页</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/language/chinese/" class="nav-link">
  Chinese
</a></li><li class="dropdown-item"><!----> <a href="/language/japanese/" class="nav-link">
  Japanese
</a></li></ul></div></div><div class="nav-item"><a href="/test/test.html" class="nav-link">
  测试
</a></div><div class="nav-item"><a href="https://www.baidu.com" target="_blank" rel="noopener noreferrer" class="nav-link external">
  百度
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="主页" class="dropdown-title"><span class="title">主页</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/language/chinese/" class="nav-link">
  Chinese
</a></li><li class="dropdown-item"><!----> <a href="/language/japanese/" class="nav-link">
  Japanese
</a></li></ul></div></div><div class="nav-item"><a href="/test/test.html" class="nav-link">
  测试
</a></div><div class="nav-item"><a href="https://www.baidu.com" target="_blank" rel="noopener noreferrer" class="nav-link external">
  百度
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></div> <!----></nav>  <ul class="sidebar-links"><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading open"><span>字符串</span> <span class="arrow down"></span></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/note/string/index_01.html" class="sidebar-link">字符串</a></li><li><a href="/note/string/index_02.html" class="sidebar-link">算法</a></li></ul></section></li><li><a href="/note/array/base.html" class="sidebar-link">数组</a></li><li><a href="/note/regexp/base.html" class="sidebar-link">正则表达式</a></li><li><a href="/note/matrix/base.html" class="sidebar-link">矩阵</a></li><li><a href="/note/heap/base.html" class="sidebar-link">堆</a></li><li><a href="/note/stack/base.html" class="sidebar-link">栈</a></li><li><a href="/note/queue/base.html" class="sidebar-link">队列</a></li><li><a href="/note/linkList/base.html" class="sidebar-link">链表</a></li><li><a href="/note/hash/base.html" class="sidebar-link">哈希表</a></li><li><a href="/note/binaryTree/base.html" class="sidebar-link">二叉树</a></li><li><a href="/note/trie/base.html" class="sidebar-link">字典树/并查集</a></li><li><a href="/note/interval/base.html" class="sidebar-link">区间</a></li><li><a href="/note/recurion/base.html" class="sidebar-link">递归</a></li><li><a href="/note/dfs/base.html" class="sidebar-link">深度/广度优先搜索</a></li><li><a href="/note/ga/base.html" class="sidebar-link">贪心算法</a></li><li><a href="/note/dp/base.html" class="sidebar-link">动态规划</a></li><li><a href="/note/partition/base.html" class="sidebar-link">分治算法</a></li><li><a href="/note/backtrack/base.html" class="sidebar-link">回溯算法</a></li><li><a href="/note/binarySearch/base.html" class="sidebar-link">二分查找</a></li><li><a href="/note/summing/base.html" class="active sidebar-link">技巧总结</a></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><p>技巧：</p> <p>1、生成二维数组</p> <div class="language- extra-class"><pre class="language-text"><code>let dp = Array.apply(null, Array(3)).map(() =&gt; Array(4).fill(0)) 
[
    [0, 0, 0, 0]
    [0, 0, 0, 0]
    [0, 0, 0, 0]
]

let dp = Array(4).fill(new Array(3).fill(null))
[
    [null, null, null]
    [null, null, null]
    [null, null, null]
    [null, null, null]
]


let arr= Array.from({length:3}, () =&gt; Array.from({length:2}, () =&gt; 0))
[
    [0, 0]
    [0, 0]
    [0, 0]
]

let dp = Array.from({length: m+1},()=&gt; new Array(n+1).fill(0));
</code></pre></div><p>2、 字符串出现次数：字符串转map</p> <div class="language- extra-class"><pre class="language-text"><code>function fn(str) { // str =&gt; 'rtee'
    let map = new Map()
    str.split('').forEach(item =&gt; {
        // 有字符加1，没字符等于1
        if (map.has(item)) {
            map.set(item, map.get(item) + 1)
        } else {
            map.set(item, 1)
        }
    })
    // map {&quot;r&quot; =&gt; 1, &quot;t&quot; =&gt; 1, &quot;e&quot; =&gt; 2}
    let data = Array.from(map.values()) // [1, 1, 2]
    return data
}
</code></pre></div><p>3、for of Map可以同时取出 key、val</p> <div class="language- extra-class"><pre class="language-text"><code>let map = new Map();
let obj = {name:1};
map.set(true,'aaaa');
map.set(obj,'bbbbb');
map.set(1,'cccc');
for (let [k, v] of map) {...}
</code></pre></div><p>3、斐波那契数列以如下被以递推的方法定义：F(1)=1，F(2)=1, F(n)=F(n - 1)+F(n - 2)</p> <p>4、众数：在数组中出现次数大于N/2的元素
质数：不为1，只能被1和本身整数的数（即不能被2到n-1之间的数字整除）</p> <div class="language- extra-class"><pre class="language-text"><code>function isPrime(num){
    for(var i=2;i&lt;num;i++){
        if(num%i == 0) return false
    }
    return true
}
</code></pre></div><p>质数优化：</p> <ul><li>对于每个数n，并不需要从2判断到n-1</li> <li>一个数若可以进行因数分解，那么分界时得到的两个数一定时一个小于等于sqrt(n)，一个大于等于sqrt(n)（开平方根n）
比如16可以被分解，2*8，2小于sqrt(16)==&gt;4, 8大于4</li></ul> <div class="language- extra-class"><pre class="language-text"><code>function isPrime(num){
    //获取num的平方根
    const temp = parseInt(Math.sqrt(num))

    // 其实遍历到等于aqrt(n)即可
    for(var i=2;i&lt;temp;i++){
        if(num%i == 0) return false
    }
    return true
}
</code></pre></div><p>获取质数</p> <div class="language- extra-class"><pre class="language-text"><code>function getPrime(num){
    while(isprime(num)){
        num++
    }
    return num
}
</code></pre></div><p>5、根据数组创建一个二叉树</p> <div class="language- extra-class"><pre class="language-text"><code>class Tree{
    // 创建二叉树
    // 思路：把node关联到父结点的左结点或右结点，所以要找父结点。
    constructor(data) {
        // 临时存储所有节点，方便寻找父子节点
        let nodeList = []
        // 顶节点
        let root
        // 拿到数组的每个元素，插入到树里
        for (let i = 0, len = data.length; i &lt; len; i++) {
            let node = new Node(data[i])
            nodeList.push(node)
            // i=0为顶点
            if (i &gt; 0) {
                // 计算当前结点属于哪一层   拿5来测试
                let n = Math.floor(Math.sqrt(i + 1))
                // 记录当前层的起始点      比如3
                let q = Math.pow(2, n) - 1
                // 记录上一层的起始点       比如1
                let p = Math.pow(2, n - 1) - 1
                // 找到当前节点的父节点   (5-3)/2 = 1    1+1
                let parent = nodeList[p + Math.floor((i - q) / 2)]
                // 当前结点和上一层的父节点做关联
                if (parent.left) {
                    parent.right = node
                } else {
                    parent.left = node
                }
            }
        }
        root = nodeList.shift()
        nodeList.length = 0
        return root
    }
}
</code></pre></div><p>6、正则
arr.match(/(\w)\1+/g)</p> <div class="language- extra-class"><pre class="language-text"><code>const arr = ['A','A','A','B','B','B','B']
arr.join('').match(/(\w)\1+/g)   // [&quot;AAA&quot;, &quot;BBBB&quot;]

// 排序
arr.join('').match(/(\w)\1+/g).sort((a, b) =&gt; b.length - a.length) //[&quot;BBBB&quot;, &quot;AAA&quot;]
</code></pre></div><div class="language- extra-class"><pre class="language-text"><code>// 正则测试api
let reg=/1{2, }/g   // 至少两个1以上
reg.exec(str)
</code></pre></div><p>7、模的用法：数组指针移动
下一个索引位置的计算方式: (n + 1) % len
前一个索引位置的计算方式：(n - 1 + len) % len</p> <div class="language- extra-class"><pre class="language-text"><code>// 指针p向后移动，数组长度为5
let p=0
p = (p + 1) % 5
</code></pre></div><p>8、位运算用法</p> <ol><li>判断奇数偶数</li></ol> <div class="language- extra-class"><pre class="language-text"><code>// 模运算
num % 2 == 0;  偶数
num % 2 == 1;  奇数

// 位运算
let n = 3
let m = 4
n &amp; (1 === 1) // true 奇数
m &amp; (1 === 1) // false 偶数
// 或者
num &amp; 0x01 == 0;
num &amp; 0x01 == 1;
</code></pre></div><ol start="2"><li><p>2的n次方====&gt; 1 &lt;&lt; n</p></li> <li><p>除以2 &gt;&gt; 1</p></li></ol> <div class="language-js extra-class"><pre class="language-js"><code>mid <span class="token operator">=</span> <span class="token punctuation">(</span>l<span class="token operator">+</span>r<span class="token punctuation">)</span> <span class="token operator">&gt;&gt;</span> <span class="token number">1</span>
</code></pre></div><ol start="4"><li>求次方的** ====&gt;  10**2 =&gt; 100 相当于10^2</li></ol> <p>9、求最大公约数</p> <div class="language- extra-class"><pre class="language-text"><code>// 1. 采用质因数分解法
function gcd2(a,b){
    var result = 1;
    for(var i = 1; i &lt;= a &amp;&amp; i &lt;= b; i++ ){
        if(a%i == 0 &amp;&amp; b%i == 0 ){
            result = i;
        }
    }
    return result;
}

// 2. 辗转相除法（递归）
let gcd = (a, b) =&gt; {
    if (b === 0) {
        return a
    }
    return gcd(b, a % b)
}

// 简化为
function gcd(a, b) {
    return b === 0 ? a : gcd(b, a % b); 
}
</code></pre></div><p>10、es6的一些用法</p> <div class="language- extra-class"><pre class="language-text"><code>// 交换两个值
[num1, num2] = [num2, num1]
</code></pre></div><p>11、Math的一些用法</p> <div class="language- extra-class"><pre class="language-text"><code>求最大最小，首先就要想到Math.max、Math.min

Math.sign(x) 正数返回1 0返回0 负数返回-1
</code></pre></div><p>12、矩阵中
左右上下都可以走，表示题可以x+1，x-1，y+1，y-1入手</p> <p>13、就地复用，可以不用再开一个数组，在数组中设置为二维arr[level]</p> <p>其他：
递归（recursion）：递归常被用来描述以自相似方法重复事物的过程，在数学和计算机科学中，指的是在函数定义中使用函数自身的方法。（A调用A）
递归的终止条件一般定义在递归函数内部，在递归调用前要做一个条件判断，根据判断的结果选择是继续调用自身，还是return；返回终止递归。
终止的条件：
1、判断递归的次数是否达到某一限定值
2、判断运算的结果是否达到某个范围等，根据设计的目的来选择</p> <p>迭代（iteration）：重复反馈过程的活动，每一次迭代的结果会作为下一次迭代的初始值。（A重复调用B）</p> <p>拆解一步步，每一步动作都是相同的
变量 存储返回结果</p> <p>给任何一个题目，会分析，知道下一步该怎么做，一步步解出答案，才是学会算法</p> <p>思路和思维</p></div> <footer class="page-edit"><!----> <!----></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/note/binarySearch/base.html" class="prev">
        二分查找
      </a></span> <!----></p></div> </main></div><div class="global-ui"><!----></div></div>
    <script src="/assets/js/app.c9ff0550.js" defer></script><script src="/assets/js/2.1884c06c.js" defer></script><script src="/assets/js/27.5a467639.js" defer></script>
  </body>
</html>

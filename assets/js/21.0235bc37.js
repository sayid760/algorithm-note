(window.webpackJsonp=window.webpackJsonp||[]).push([[21],{237:function(n,t,a){"use strict";a.r(t);var e=a(17),r=Object(e.a)({},(function(){var n=this,t=n.$createElement,a=n._self._c||t;return a("ContentSlotsDistributor",{attrs:{"slot-key":n.$parent.slotKey}},[a("h2",{attrs:{id:"合并区间"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#合并区间"}},[n._v("#")]),n._v(" 合并区间")]),n._v(" "),a("p",[n._v("将一组区间中所有重叠的区间进行合并，例如 [起点，终点] 这种方式")]),n._v(" "),a("p",[n._v("输入：[[1,3],[2,6],[15,18],[8,10],[10,11],[7,8]] "),a("br"),n._v("\n输出：[[1,6],[15,18],[7,11]]")]),n._v(" "),a("p",[n._v("思路：排序再判断有没有重叠")]),n._v(" "),a("ul",[a("li",[n._v("1）先排序")]),n._v(" "),a("li",[n._v("2）定义两个变量存放前一个区间的最小值，最大值")]),n._v(" "),a("li",[n._v("3）遍历循环，"),a("br"),n._v("\n当前区间的最小值小于或等于前一个区间的最大值时，表示有重叠可以合并；\n当前区间的最小值大于前一个区间的最大值时，表示不可以合并，并把之前存储的拿出来合并ans.push([start, end])，并保存当前的最小值，最大值")]),n._v(" "),a("li",[n._v("4）遍历循环之后得到的最小值、最大值表示不能被合并的，需要合成区间，并push到数组里")])]),n._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[n._v("var arr = [[1,3],[2,6],[15,18],[8,10],[10,11],[7,8]]\nconst merge = arr => {\n    // 排序 [[1,3],[2,6],[7,8],[8,10],[10,11],[15,18]]\n    arr.sort(function(a, b) {\n        if (a[0] !== b[0]){\n            return a[0] - b[0];\n        }   \n        return a[1] - b[1];\n    });\n    let len = arr.length,\n        ans = [],\n        start, end; // 用来保存之前的，跟后面的区间做笔记\n    for (let i = 0; i < len; i++) {\n        let s = arr[i][0],\n        e = arr[i][1];\n        if (start === undefined){\n            start = s, end = e;\n        }else if (s <= end){ // 第二个区间的第一s是否比前一个区间的第二位还小，小就说明可以合并 [1,3][2,6]   2比3小\n            // 判断当前区间的第二位和前一个区间的第二位数哪个大，取最大的 [1,3][2,6]  3<6 取最大6\n            end = Math.max(e, end); \n        }else { // 第二区间的第一位比前一个区间的第二位还大 [2,6],[7,8]   7>6，说明不合并，到这步就不可以判断是否合并了，就把之前的先拿出来合并  \n            let part = [start, end];  \n            ans.push(part);\n            // 保存的是当前的\n            start = s;  \n            end = e;\n        }\n    }\n    if (start !== undefined) {\n        let part = [start, end];\n        ans.push(part);\n    }\n    return ans;\n};\nconsole.log(merge(arr))\n")])])]),a("h2",{attrs:{id:"给定一个区间，问最多保留多少个区间，可以让这些区间直接互相不重叠"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#给定一个区间，问最多保留多少个区间，可以让这些区间直接互相不重叠"}},[n._v("#")]),n._v(" 给定一个区间，问最多保留多少个区间，可以让这些区间直接互相不重叠")]),n._v(" "),a("p",[n._v("思路：找出所有子区间的组合，之后判断它不重叠 O((2^n)*n)")]),n._v(" "),a("p",[n._v("借鉴 最长上升子序列 解决问题，")]),n._v(" "),a("p",[n._v("①将全部进行从小到大排列。然后你会发现这题就是最长上升子序列的一个类型题了。直接运用最长上升子序列去解即可。找出其状态转移方程：memo[i]=max(memo[i],memo[j]+1)。\n②贪心算法求解，认为其结尾越小的放在前面计算后面能放更多。")]),n._v(" "),a("h2",{attrs:{id:"插入区间"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#插入区间"}},[n._v("#")]),n._v(" 插入区间")])])}),[],!1,null,null,null);t.default=r.exports}}]);
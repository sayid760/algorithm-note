(window.webpackJsonp=window.webpackJsonp||[]).push([[24],{242:function(t,s,a){"use strict";a.r(s);var e=a(17),v=Object(e.a)({},(function(){var t=this,s=t.$createElement,a=t._self._c||s;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("table",[a("thead",[a("tr",[a("th"),t._v(" "),a("th")])]),t._v(" "),a("tbody",[a("tr",[a("td",[t._v("*")]),t._v(" "),a("td",[t._v("0或者多次（尽可能匹配多次）")])]),t._v(" "),a("tr",[a("td",[t._v("+")]),t._v(" "),a("td",[t._v("至少1次")])]),t._v(" "),a("tr",[a("td",[t._v("?")]),t._v(" "),a("td",[t._v("0或者1次 "),a("br"),t._v(" "),a("em",[t._v("?：尽可能少的匹配，")]),t._v("，+后的?表示非贪婪匹du配")])]),t._v(" "),a("tr",[a("td",[t._v("\\s")]),t._v(" "),a("td",[t._v("匹配任意的空白符（包括空格，制表符(Tab)，换行符，中文全角空格）")])]),t._v(" "),a("tr",[a("td",[t._v("\\S")]),t._v(" "),a("td",[t._v("则是任意不是空白符的字符")])]),t._v(" "),a("tr",[a("td",[t._v("\\w")]),t._v(" "),a("td",[t._v("匹配包括下划线的任何单词字符,等价于 [A-Z a-z 0-9_]")])]),t._v(" "),a("tr",[a("td",[t._v("\\W")]),t._v(" "),a("td",[t._v("匹配任何非单词字符,等价于 [^A-Z a-z 0-9_]")])]),t._v(" "),a("tr",[a("td",[t._v('"')]),t._v(" "),a("td",[t._v('"')])])])]),t._v(" "),a("p",[t._v("() 是为了提取匹配的字符串\n[] 是定义匹配的字符范围\n{} 一般用来表示匹配的长度")]),t._v(" "),a("ol",[a("li",[t._v("()()\\1\\2的用法 "),a("br"),t._v("\n\\1表示重复第一个圆括号匹配到的内容 "),a("br"),t._v("\n\\2表示重复第二个圆括号匹配到的内容 "),a("br")])]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("/^([a-z])([a-z])\\2\\1$/.test('abba')  \\1表示b \\2表示a\n/^(\\w)(\\w)\\1\\2$/.test('abab')   \\1表示a \\2表示b\n")])])]),a("h2",{attrs:{id:"重复的子字符串"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#重复的子字符串"}},[t._v("#")]),t._v(" 重复的子字符串")]),t._v(" "),a("p",[t._v("给定一个非空的字符串，判断它是否可以由它的一个子串重复多次构成。给定的字符串只含有小写英文字母，并且长度不超过10000。")]),t._v(" "),a("blockquote",[a("p",[t._v('输入: "abab" '),a("br"),t._v("\n输出: True "),a("br"),t._v('\n解释: 可由子字符串 "ab" 重复两次构成')])]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("const repeatedSubstringPattern=(str)=>{\n    var reg=/^(\\w+)\\1+$/\n    return reg.test(str)\n}\n")])])]),a("h2",{attrs:{id:"正则表达式匹配"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#正则表达式匹配"}},[t._v("#")]),t._v(" 正则表达式匹配")]),t._v(" "),a("p",[t._v("给你一个字符串 s 和一个字符规律 p，请你来实现一个支持 '.' 和 '*' 的正则表达式匹配。")]),t._v(" "),a("blockquote",[a("p",[t._v("'.' 匹配任意单个字符 "),a("br"),t._v("\n'*' 匹配零个或多个前面的那一个元素")])]),t._v(" "),a("p",[t._v("说明:"),a("br")]),t._v(" "),a("ul",[a("li",[t._v("s 可能为空，且只包含从 a-z 的小写字母。")]),t._v(" "),a("li",[t._v("p 可能为空，且只包含从 a-z 的小写字母，以及字符 . 和 *。")])]),t._v(" "),a("p",[t._v("写好规则，浏览器的正则引擎会帮你解析规则，这道题是让你去实现正则引擎的部分")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("// 有模式:.*、a*   无模式: cdef\nconst isMatch = (s, p) => {\n    let isMatch = (s, p) => {\n        // 边界情况，如果s和p都为空，说明处理结束了，返回true，否则返回false\n        if (p.length <= 0) {\n            return !s.length\n        }\n        // 判断p模式字符串的第一个字符和s字符串的第一个字符是不是匹配\n        let match = false\n        if (s.length > 0 && (p[0] === s[0] || p[0] === '.')) {\n            match = true\n        }\n        // p有模式的\n        if (p.length > 1 && p[1] === '*') {\n            // 第一种情况：s*匹配0个字符\n            // 第二种情况：s*匹配1个字符，递归下去，用来表示s*匹配多个s\n            // isMatch(s, s*is*p*.)\n            return isMatch(s, p.slice(2)) || (match && isMatch(s.slice(1), p))\n        } else {\n            return match && isMatch(s.slice(1), p.slice(1))\n        }\n    }\n    return isMatch(s, p)\n}\nconsole.log(isMatch(\"mississippi\", \"mis*is*p*.\"))\n")])])])])}),[],!1,null,null,null);s.default=v.exports}}]);
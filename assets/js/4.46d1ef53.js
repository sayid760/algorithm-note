(window.webpackJsonp=window.webpackJsonp||[]).push([[4],{217:function(n,e,t){n.exports=t.p+"assets/img/queue_img_03.15fba3ac.png"},218:function(n,e,t){n.exports=t.p+"assets/img/queue_img_01.426ed57b.png"},219:function(n,e,t){n.exports=t.p+"assets/img/queue_img_02.f9785034.png"},243:function(n,e,t){"use strict";t.r(e);var r=t(17),s=Object(r.a)({},(function(){var n=this,e=n.$createElement,r=n._self._c||e;return r("ContentSlotsDistributor",{attrs:{"slot-key":n.$parent.slotKey}},[r("h1",{attrs:{id:"队列"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#队列"}},[n._v("#")]),n._v(" 队列")]),n._v(" "),r("ul",[r("li",[n._v("先入先出  操作都是O(1)")]),n._v(" "),r("li",[n._v("优先队列：正常进，优先出")])]),n._v(" "),r("h2",{attrs:{id:"优先队列"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#优先队列"}},[n._v("#")]),n._v(" 优先队列")]),n._v(" "),r("p",[n._v("正常进，按照优先出，优先级可以设置的属性，按照属性来出（最大的先出，也可以最小的先出，也可以出现次数先出）\n实现机制：")]),n._v(" "),r("ul",[r("li",[r("p",[n._v("用堆heap来实现（Binary，Binomial，Fibonacci）\n小顶堆：越小的越排在上面，父节点比子节点小，最小的永远在根节点；加元素时放最下面，然后再上浮调整\n大顶堆：越大的越排在上面，父结点大于左右节点，最大的永远在根节点")])]),n._v(" "),r("li",[r("p",[n._v("用二叉搜索树Binary Search Tree来实现")])])]),n._v(" "),r("h2",{attrs:{id:"用队列实现栈"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#用队列实现栈"}},[n._v("#")]),n._v(" 用队列实现栈")]),n._v(" "),r("h2",{attrs:{id:"数据流中的第k大元素"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#数据流中的第k大元素"}},[n._v("#")]),n._v(" 数据流中的第K大元素")]),n._v(" "),r("blockquote",[r("p",[n._v("int k = 3; "),r("br"),n._v("\nint[] arr = [4,5,8,2];  "),r("br"),n._v("\nKthLargest kthLargest = new KthLargest(3, arr);  "),r("br"),n._v("\nkthLargest.add(3);   // returns 4 "),r("br"),n._v("\nkthLargest.add(5);   // returns 5")])]),n._v(" "),r("p",[n._v("思路：\n方法1：保存前K个最大的值；全部排序\n方法2：优先队列，每次把最大的放在最上面，或把最小的放在最上面\n小顶堆：把最小的放根结点，所以要保证元素个数等于K（意思是这个堆的个数为K个，最顶的是最小的，遍历数组的元素，如果有比它小的就不用进来排队了，如果比它大，就把最小的踢掉，剩下的元素重新调整log2^k）")]),n._v(" "),r("div",{staticClass:"language-js extra-class"},[r("pre",{pre:!0,attrs:{class:"language-js"}},[r("code",[n._v("\n")])])]),r("h2",{attrs:{id:"滑动窗口最大值"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#滑动窗口最大值"}},[n._v("#")]),n._v(" "),r("a",{attrs:{href:"https://leetcode-cn.com/problems/sliding-window-maximum/",target:"_blank",rel:"noopener noreferrer"}},[n._v("滑动窗口最大值"),r("OutboundLink")],1)]),n._v(" "),r("blockquote",[r("p",[n._v("输入: nums = [1,3,-1,-3,5,3,6,7], 和 k = 3 "),r("br"),n._v("\n输出: [3,3,5,5,6,7] "),r("br"),n._v("\n解释: "),r("br"),n._v("\n滑动窗口的位置                最大值"),r("br"),n._v("\n---------------               -----"),r("br"),n._v("\n[1  3  -1] -3  5  3  6  7   ------\x3e    3"),r("br"),n._v("\n1 [3  -1  -3] 5  3  6  7    ------\x3e    3"),r("br"),n._v("\n1  3 [-1  -3  5] 3  6  7    ------\x3e    5"),r("br"),n._v("\n1  3  -1 [-3  5  3] 6  7    ------\x3e    5"),r("br"),n._v("\n1  3  -1  -3 [5  3  6] 7    ------\x3e    6"),r("br"),n._v("\n1  3  -1  -3  5 [3  6  7]    ------\x3e   7")])]),n._v(" "),r("p",[n._v("所有的滑动窗口题用队列去处理")]),n._v(" "),r("p",[n._v("方法1：暴力求解，枚举窗口的起点位置，起点开始到len-k的最大值，写两个嵌套循环O(n*K)\n方法2：线性队列，O(n+k)即O(n)一次解决\n窗口移到2 3 4位置，5进来的时候，要跟窗口其他数对比，只要比5小，都可以从这个栈去掉")]),n._v(" "),r("p",[r("img",{attrs:{src:t(217),alt:"Image text"}})]),n._v(" "),r("h2",{attrs:{id:"设计循环队列"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#设计循环队列"}},[n._v("#")]),n._v(" 设计循环队列")]),n._v(" "),r("p",[n._v("循环队列是一种线性数据结构，其操作表现基于 FIFO（先进先出）原则并且队尾被连接在队首之后以形成一个循环。它也被称为“环形缓冲器”\n循环队列的一个好处是我们可以利用这个队列之前用过的空间。在一个普通队列里，一旦一个队列满了，我们就不能插入下一个元素，即使在队列前面仍有空间。但是使用循环队列，我们能使用这些空间去存储新的值。"),r("br"),n._v("\n循环队列可以高效利用存储空间，普通队列需要很大的存储空间，存储空间会往上跑，循环队列可以避免这个问题。")]),n._v(" "),r("p",[n._v("你的实现应该支持如下操作："),r("br"),n._v("\nMyCircularQueue(k): 构造器，设置队列长度为 k 。"),r("br"),n._v("\nFront: 从队首获取元素。如果队列为空，返回 -1 。"),r("br"),n._v("\nRear: 获取队尾元素。如果队列为空，返回 -1 。"),r("br"),n._v("\nenQueue(value): 向循环队列插入一个元素。如果成功插入则返回真。"),r("br"),n._v("\ndeQueue(): 从循环队列中删除一个元素。如果成功删除则返回真。"),r("br"),n._v("\nisEmpty(): 检查循环队列是否为空。"),r("br"),n._v("\nisFull(): 检查循环队列是否已满。")]),n._v(" "),r("p",[r("img",{attrs:{src:t(218),alt:"Image text"}})]),n._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[n._v("class MyCircularQueue{\n    constructor(k) {\n        // 用来保存数据长度为k的数据结构\n        this.list = Array(k)\n        // 队首指针\n        this.front = 0\n        // 队尾的指针\n        this.rear = 0\n        // 队列的长度\n        this.max = k\n    }\n    // 入队：rear指针指向哪里，哪里就可以入队，且rear指针+1\n    enQueue(num) {\n        if (this.isFull()) {\n            return false\n        } else {\n            this.list[this.rear] = num\n            // 指针向后移动\n            this.rear = (this.rear + 1) % this.max\n            return true\n        }\n    }\n    // 出队：front指针指向谁，谁就出队，且front指针+1\n    deQueue() {\n        let v = this.list[this.front]\n        this.list[this.front] = ''\n        console.log('front-----\x3e'+this.front)\n        // front指针往后移动\n        this.front = (this.front + 1) % this.max\n        console.log('front222-----\x3e'+this.front)\n        return v\n    }\n    isEmpty() {\n        return this.front === this.rear && !this.list[this.front]\n    }\n    isFull() {\n        return this.front === this.rear && !!this.list[this.front]\n    }\n    Front() {\n        return this.list[this.front]\n    }\n    rear() {\n        let rear = this.rear - 1\n        return this.list[rear < 0 ? this.max - 1 : rear]\n    }\n}\nconst cQueue = new MyCircularQueue(5); // 设置长度为 3\ncQueue.enQueue(1);  // 返回 true\ncQueue.enQueue(2);  // 返回 true\ncQueue.enQueue(3);  // 返回 true\ncQueue.enQueue(4);  // 返回 false，队列已满\n// cQueue.rear();  // 返回 3\n// cQueue.isFull();  // 返回 true\ncQueue.deQueue();  // 返回 true\ncQueue.deQueue();  // 返回 true\ncQueue.deQueue();  // 返回 true\n// cQueue.enQueue(4);  // 返回 true\n// cQueue.rear();  // 返回 4\nconsole.log(cQueue)\n")])])]),r("h2",{attrs:{id:"任务调度器"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#任务调度器"}},[n._v("#")]),n._v(" 任务调度器")]),n._v(" "),r("p",[n._v("给定一个用字符数组表示的 CPU 需要执行的任务列表。其中包含使用大写的 A - Z 字母表示的26 种不同种类的任务。任务可以以任意顺序执行，并且每个任务都可以在 1 个单位时间内执行完。CPU 在任何一个单位时间内都可以执行一个任务，或者在待命状态。")]),n._v(" "),r("p",[n._v("然而，两个相同种类的任务之间必须有长度为 n 的冷却时间，因此至少有连续 n 个单位时间内 CPU 在执行不同的任务，或者在待命状态。")]),n._v(" "),r("p",[n._v("你需要计算完成所有任务所需要的最短时间。\n示例 ：")]),n._v(" "),r("blockquote",[r("p",[n._v('输入：tasks = ["A","A","A","B","B","B"], n = 2 '),r("br"),n._v("\n输出：8 "),r("br"),n._v("\n解释：A -> B -> (待命) -> A -> B -> (待命) -> A -> B. "),r("br"),n._v("\n在本示例中，两个相同类型任务之间必须间隔长度为 n = 2 的冷却时间，而执行一个任务只需要一个单位时间，所以中间出现了（待命）状态。")])]),n._v(" "),r("p",[n._v("思路：任务清单keys ['A','B'] 是用来遍历循环，拿到当前数量最多的任务，然后个push到临时队列tmp中，临时队列只能放到n+1个（3个）任务，不够放的就用'-'来补齐（做到两个相同类型任务之间必须长度为n）。执行完一个临时队列tmp后，再循环判断还有没有任务清单keys，有的话继续前面的动作，直到keys[0]=undefined为止")]),n._v(" "),r("p",[n._v("步骤："),r("br"),n._v("\n1）先记录每类任务的数量 Q:{A:3, B:3} "),r("br"),n._v('\n2）max记录最多数量的先执行，先被push到临时任务队列tmp中，这个tmp就是AB-AB-AB（不够n+1个的往里面补"-"）')]),n._v(" "),r("ul",[r("li",[n._v("获取任务清单keys（['A','B']），遍历任务清单找到数量最多的key，拿到数量最多的A先push到临时队列tmp中，表示执行这个队列，所以得把Q中A的数量减一，从任务清单keys清除A")]),n._v(" "),r("li",[n._v("这个临时队列容量为n+1，所以能被循环小于n次，执行完一个临时队列后，把临时队列累加给p, 再去循环执行下一个临时队列\n"),r("img",{attrs:{src:t(219),alt:"Image text"}})])]),n._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[n._v('const leastInterval = (tasks, n) => {\n    // 表示最终队列执行的结果\n    let q = \'\'\n    // 对归类进行存储\n    let Q = {}\n    tasks.forEach(item => {\n        if (Q[item]) {\n            Q[item]++\n        } else {\n            Q[item] = 1\n        }\n    });\n    // 队列中还有任务就要循环，为什么为1，是因为效率问题，不要一直判断对象Q是否为空，会重复计算\n    while (1) {\n        // 处理边界问题\n        // 任务清单：只要有key值，表示任务队列中还有，key值没有就表示已经都处理掉了，就不用每次去判断Q是否为空\n        let keys = Object.keys(Q)\n        if (!keys[0]) {\n            break\n        }\n        // 处理任务：找到哪个数量最多，数量最多的就优先处理\n        // 声明一个队列用来存储1+n任务单元\n        let tmp = []\n        for (let i = 0; i <= n; i++) {\n            // 记录最大值\n            let max=0\n            // 最大值名称\n            let key\n            // 最大值索引位置\n            let pos\n            // 任务清单中找当前任务还剩下多少\n            keys.forEach((item, idx)=>{\n                // 找最大值\n                if(Q[item]>max){\n                    max = Q[item]\n                    key = item\n                    pos = idx\n                    // console.log(item)\n                    // console.log(idx)\n                }\n            })\n            // 判断是否找到最大值key，如果是就push到临时队列\n            if(key){\n                // console.log(\'11---\x3e\'+key)\n                tmp.push(key)\n                // 在任务清单中清除\n                keys.splice(pos, 1) //  ["A", "B"] ===> ["B"]\n                Q[key]--\n                if(Q[key]<1){\n                    delete Q[key]\n                }\n                // console.log(\'222---\x3e\'+keys)\n            }else{\n                break\n            }\n        }\n        // 如果不够，后面补什么\n        q +=tmp.join(\'\').padEnd(n+1,\'-\')\n    }\n    // 边界处理，最后不要出现冷却时间\n    q = q.replace(/-+$/g, \'\')\n    return q.length\n}\nconst tasks = ["A", "A", "A", "B", "B", "B"], n = 2\nconsole.log(leastInterval(tasks, n)) \n')])])])])}),[],!1,null,null,null);e.default=s.exports}}]);
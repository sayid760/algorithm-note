(window.webpackJsonp=window.webpackJsonp||[]).push([[27],{250:function(n,a,t){"use strict";t.r(a);var e=t(17),r=Object(e.a)({},(function(){var n=this,a=n.$createElement,t=n._self._c||a;return t("ContentSlotsDistributor",{attrs:{"slot-key":n.$parent.slotKey}},[t("p",[n._v("技巧：")]),n._v(" "),t("p",[n._v("1、生成二维数组")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v("let dp = Array.apply(null, Array(3)).map(() => Array(4).fill(0)) \n[\n    [0, 0, 0, 0]\n    [0, 0, 0, 0]\n    [0, 0, 0, 0]\n]\n\nlet dp = Array(4).fill(new Array(3).fill(null))\n[\n    [null, null, null]\n    [null, null, null]\n    [null, null, null]\n    [null, null, null]\n]\n\n\nlet arr= Array.from({length:3}, () => Array.from({length:2}, () => 0))\n[\n    [0, 0]\n    [0, 0]\n    [0, 0]\n]\n\nlet dp = Array.from({length: m+1},()=> new Array(n+1).fill(0));\n")])])]),t("p",[n._v("2、 字符串出现次数：字符串转map")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v('function fn(str) { // str => \'rtee\'\n    let map = new Map()\n    str.split(\'\').forEach(item => {\n        // 有字符加1，没字符等于1\n        if (map.has(item)) {\n            map.set(item, map.get(item) + 1)\n        } else {\n            map.set(item, 1)\n        }\n    })\n    // map {"r" => 1, "t" => 1, "e" => 2}\n    let data = Array.from(map.values()) // [1, 1, 2]\n    return data\n}\n')])])]),t("p",[n._v("3、for of Map可以同时取出 key、val")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v("let map = new Map();\nlet obj = {name:1};\nmap.set(true,'aaaa');\nmap.set(obj,'bbbbb');\nmap.set(1,'cccc');\nfor (let [k, v] of map) {...}\n")])])]),t("p",[n._v("3、斐波那契数列以如下被以递推的方法定义：F(1)=1，F(2)=1, F(n)=F(n - 1)+F(n - 2)")]),n._v(" "),t("p",[n._v("4、众数：在数组中出现次数大于N/2的元素\n质数：不为1，只能被1和本身整数的数（即不能被2到n-1之间的数字整除）")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v("function isPrime(num){\n    for(var i=2;i<num;i++){\n        if(num%i == 0) return false\n    }\n    return true\n}\n")])])]),t("p",[n._v("质数优化：")]),n._v(" "),t("ul",[t("li",[n._v("对于每个数n，并不需要从2判断到n-1")]),n._v(" "),t("li",[n._v("一个数若可以进行因数分解，那么分界时得到的两个数一定时一个小于等于sqrt(n)，一个大于等于sqrt(n)（开平方根n）\n比如16可以被分解，2*8，2小于sqrt(16)==>4, 8大于4")])]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v("function isPrime(num){\n    //获取num的平方根\n    const temp = parseInt(Math.sqrt(num))\n\n    // 其实遍历到等于aqrt(n)即可\n    for(var i=2;i<temp;i++){\n        if(num%i == 0) return false\n    }\n    return true\n}\n")])])]),t("p",[n._v("获取质数")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v("function getPrime(num){\n    while(isprime(num)){\n        num++\n    }\n    return num\n}\n")])])]),t("p",[n._v("5、根据数组创建一个二叉树")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v("class Tree{\n    // 创建二叉树\n    // 思路：把node关联到父结点的左结点或右结点，所以要找父结点。\n    constructor(data) {\n        // 临时存储所有节点，方便寻找父子节点\n        let nodeList = []\n        // 顶节点\n        let root\n        // 拿到数组的每个元素，插入到树里\n        for (let i = 0, len = data.length; i < len; i++) {\n            let node = new Node(data[i])\n            nodeList.push(node)\n            // i=0为顶点\n            if (i > 0) {\n                // 计算当前结点属于哪一层   拿5来测试\n                let n = Math.floor(Math.sqrt(i + 1))\n                // 记录当前层的起始点      比如3\n                let q = Math.pow(2, n) - 1\n                // 记录上一层的起始点       比如1\n                let p = Math.pow(2, n - 1) - 1\n                // 找到当前节点的父节点   (5-3)/2 = 1    1+1\n                let parent = nodeList[p + Math.floor((i - q) / 2)]\n                // 当前结点和上一层的父节点做关联\n                if (parent.left) {\n                    parent.right = node\n                } else {\n                    parent.left = node\n                }\n            }\n        }\n        root = nodeList.shift()\n        nodeList.length = 0\n        return root\n    }\n}\n")])])]),t("p",[n._v("6、正则\narr.match(/(\\w)\\1+/g)")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v("const arr = ['A','A','A','B','B','B','B']\narr.join('').match(/(\\w)\\1+/g)   // [\"AAA\", \"BBBB\"]\n\n// 排序\narr.join('').match(/(\\w)\\1+/g).sort((a, b) => b.length - a.length) //[\"BBBB\", \"AAA\"]\n")])])]),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v("// 正则测试api\nlet reg=/1{2, }/g   // 至少两个1以上\nreg.exec(str)\n")])])]),t("p",[n._v("7、模的用法：数组指针移动\n下一个索引位置的计算方式: (n + 1) % len\n前一个索引位置的计算方式：(n - 1 + len) % len")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v("// 指针p向后移动，数组长度为5\nlet p=0\np = (p + 1) % 5\n")])])]),t("p",[n._v("8、位运算用法")]),n._v(" "),t("ol",[t("li",[n._v("判断奇数偶数")])]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v("// 模运算\nnum % 2 == 0;  偶数\nnum % 2 == 1;  奇数\n\n// 位运算\nlet n = 3\nlet m = 4\nn & (1 === 1) // true 奇数\nm & (1 === 1) // false 偶数\n// 或者\nnum & 0x01 == 0;\nnum & 0x01 == 1;\n")])])]),t("ol",{attrs:{start:"2"}},[t("li",[t("p",[n._v("2的n次方====> 1 << n")])]),n._v(" "),t("li",[t("p",[n._v("除以2 >> 1")])])]),n._v(" "),t("div",{staticClass:"language-js extra-class"},[t("pre",{pre:!0,attrs:{class:"language-js"}},[t("code",[n._v("mid "),t("span",{pre:!0,attrs:{class:"token operator"}},[n._v("=")]),n._v(" "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[n._v("(")]),n._v("l"),t("span",{pre:!0,attrs:{class:"token operator"}},[n._v("+")]),n._v("r"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[n._v(")")]),n._v(" "),t("span",{pre:!0,attrs:{class:"token operator"}},[n._v(">>")]),n._v(" "),t("span",{pre:!0,attrs:{class:"token number"}},[n._v("1")]),n._v("\n")])])]),t("ol",{attrs:{start:"4"}},[t("li",[n._v("求次方的** ====>  10**2 => 100 相当于10^2")])]),n._v(" "),t("p",[n._v("9、求最大公约数")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v("// 1. 采用质因数分解法\nfunction gcd2(a,b){\n    var result = 1;\n    for(var i = 1; i <= a && i <= b; i++ ){\n        if(a%i == 0 && b%i == 0 ){\n            result = i;\n        }\n    }\n    return result;\n}\n\n// 2. 辗转相除法（递归）\nlet gcd = (a, b) => {\n    if (b === 0) {\n        return a\n    }\n    return gcd(b, a % b)\n}\n\n// 简化为\nfunction gcd(a, b) {\n    return b === 0 ? a : gcd(b, a % b); \n}\n")])])]),t("p",[n._v("10、es6的一些用法")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v("// 交换两个值\n[num1, num2] = [num2, num1]\n")])])]),t("p",[n._v("11、Math的一些用法")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v("求最大最小，首先就要想到Math.max、Math.min\n\nMath.sign(x) 正数返回1 0返回0 负数返回-1\n")])])]),t("p",[n._v("12、矩阵中\n左右上下都可以走，表示题可以x+1，x-1，y+1，y-1入手")]),n._v(" "),t("p",[n._v("13、就地复用，可以不用再开一个数组，在数组中设置为二维arr[level]")]),n._v(" "),t("p",[n._v("其他：\n递归（recursion）：递归常被用来描述以自相似方法重复事物的过程，在数学和计算机科学中，指的是在函数定义中使用函数自身的方法。（A调用A）\n递归的终止条件一般定义在递归函数内部，在递归调用前要做一个条件判断，根据判断的结果选择是继续调用自身，还是return；返回终止递归。\n终止的条件：\n1、判断递归的次数是否达到某一限定值\n2、判断运算的结果是否达到某个范围等，根据设计的目的来选择")]),n._v(" "),t("p",[n._v("迭代（iteration）：重复反馈过程的活动，每一次迭代的结果会作为下一次迭代的初始值。（A重复调用B）")]),n._v(" "),t("p",[n._v("拆解一步步，每一步动作都是相同的\n变量 存储返回结果")]),n._v(" "),t("p",[n._v("给任何一个题目，会分析，知道下一步该怎么做，一步步解出答案，才是学会算法")]),n._v(" "),t("p",[n._v("思路和思维")])])}),[],!1,null,null,null);a.default=r.exports}}]);